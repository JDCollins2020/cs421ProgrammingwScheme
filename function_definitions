#lang racket
#|[5 Points] Write a Scheme function (interleave L1 L2) that
accepts lists L1 and L2. The function produces a list such
that the elements are interleaved elements of L1 and L2,
beginning with L1.
|#
(define (interleave L1 L2)
  ( cond
     ( ( and (null? L1) (null? L2) ) '() );;;no values in either list
     ( (null? L1 )  (cons (car L2) (cdr L2) ) );;;L1 out of values
     ( (null? L2 )  (cons (car L1) (cdr L1) ) );;;L2 out of values
     ( else ( cons (car L1) (cons (car L2) (interleave (cdr L1) (cdr L2) )  ) ) )
  )
)
#|
(display "interleave Test 1\n")
(interleave '(1 2 3)'(4 5 6))
(interleave '(1 2 3) '(4))
(interleave '() '(1 2)) 
(interleave '(a (b c) d) '((e f) 5 9))
(display "interleave Test 2\n")
(interleave '(4 5 6) '(1 2 3))
(interleave '(4) '(1 2 3))
(interleave '(1 2)'()) 
(interleave '((e f) 5 9) '(a (b c) d))
|#


#|[5 Points] Write a function named (key-store L1 KEY) that
accepts a list of two-tuples L1 and a value KEY. This
function returns the second value of the first tuple that
begins with KEY. If L1 doesn't contain the KEY, return
the emtpy list.
|#
(define (key-store L1 KEY)
  ( cond
     ( (null? L1) '() );;;no match
     ( (equal? (car (car L1) ) KEY) (car (cdr (car L1))) );;;match
     (  else (key-store (cdr L1) KEY ) ) ;;;search next tuple
  )
)
#|
(display "key-store Test 1\n")
(key-store '((a 2) (b c) (c (3 4))) 'c)
(key-store '((a 2) (b c) (c (3 4))) 'b)
(key-store '((a 2) (b c) (c (3 4))) 'z)
(key-store '((() a)) '())
|#

;;;[5 Points] Write a function named (list-replace ALIST SYM
;;; VAL) that accepts a list of elements and returns that
;;; list where all SYM's (a single symbol) have been replaced
;;; by the VAL (some scheme value). The replacement must
;;; occur even within nested lists.
(define (list-replace ALIST SYM VAL) 
  ( cond
     ( (null? ALIST) '() )
     ( (equal? SYM (car ALIST) ) ( cons VAL (list-replace (cdr ALIST) SYM VAL) ) );;check and replace
     ( (symbol? (car ALIST) ) ( cons (car ALIST) (list-replace (cdr ALIST) SYM VAL) ) );;;keep val and run through independently
     (  else ( cons (list-replace (car ALIST) SYM VAL) (list-replace (cdr ALIST) SYM VAL) ) )
  )
)
#|
(display "list-replace Test 1\n")
(list-replace '(a b c) 'a 3) ;;;---> (3 b c)
(list-replace '(a (a b c) c) 'a 3) ;;;---> (3 (3 b c) c)
(list-replace '() 'a 3) ;;;---> ()
(list-replace '(a (a (a))) 'a '(3)) ;;;--> ((3) ((3) ((3))))
|#

;;; [5 Points] Write a function named (first-n L1 N) that
;;; returns the first N elements of L1. If N is negative,
;;; return the empty list. If N exceeds the length of L1
;;; return all elements of L1.
(define ( first-n L1 N )
  (cond
    ( (or (< N 1) (null? L1) ) '() ) ;;;list is empty or N = 0
    (  else (cons (car L1)( first-n (cdr L1) (- N 1) ) ) )
  )
)
#|
(display "first-n Test 1\n")
(first-n '(a b c d e f) -3) ;;;---> ()
(first-n '(a b c d e f) 3) ;;;---> (a b c)
(first-n '(a b c d e f) 33) ;;;---> (a b c d e f)
(first-n '() 0) ;;;---> ()
|#

;;;[5 Points] Write a function named (forget-n L1 N) that
;;; returns the elements of L1 except for the first N. If
;;; N is negative, return all elements. If N exceeds the
;;; length of L1 return the empty list.
(define (forget-n L1 N )
  (cond
    ( (<= N 0) L1 ) ;;;N is negative
    ( (< N 1)  (cdr L1) ) ;;; N = 0 and list is not empty
    ( (null? L1) '() ) ;;; N exceeds length of L1
    ( else ( forget-n (cdr L1) (- N 1) ) )
  )
)
(display "forget-n Test 1\n")
(forget-n '(a b c d e f) -3) ;;;---> (a b c d e f)
(forget-n '(a b c d e f) 3) ;;;---> (d e f)
(forget-n '(a b c d e f) 6) ;;;---> ()
(forget-n '(a b c d e f) 33) ;;;---> ()
(forget-n '() 0) ;;;---> ()
;;;[10 Points] Write a function (running-sum L) that takes
;;; a list of numbers L and generates a list of the
;;; runnining sums.
;;;(define (running-sum L) )

;;;Write a function (counts XS) that takes a list of items
;;; XS and generates a counting of the elements in XS.
;;; The returned object is a list of lists. Each element
;;; of the returned object is a list of length two
;;; containing an element X of XS and an integer denoting
;;; the number of occurrences of X in XS. The order of the
;;; elements in the computed list is not specified. [10 pts]
;;;(define (count XS))

;;;[5 Points] Write a function (indices L1 X) that takes a
;;; list of elements L1 and an element X. The function
;;; returns a list of the indices in L1 that contain X.
;;; See the following examples for clarificaton.
;;;(define (indices L1 X))

;;;[5 Points] Write a function (join-together L1 L2) that
;;; takes a sorted list (ascending) of integers L1 and
;;; a sorted list of elements L2 and returns a sorted
;;; list containing all elements of both L1 and L2.
;;; See the following examples for clarificaton.
;;;(define (join-together L1 L2 ))

;;;[10 Points] Write a function (merge-sorter L1) that
;;; takes list-of-integers L1 and returns all elements
;;; of L1 in sorted order. You must use a merge-sort
;;; technique that, in the recursive case, a) splits
;;; L1 into two approximately-equal-length lists, b)
;;; sorts those lists, and then c) merges the lists
;;; to obtain the result.
;;;(define (merge-sorter L1))

;;;[10 Points] Consider two techniques for representing
;;; a graph as Scheme lists. We can represent a
;;; directed graph as a list of edges. We call this
;;; representation an el-graph (i.e. edge-list graph).
;;; An edge is itself a list of length two such that
;;; the first element is a symbol denoting the source
;;; of the edge and the second element is a symbol
;;; denoting the target of the edge. Note that an
;;; edge is a list (not just a pair). For example,
;;; the following is a graph: '((x y) (y z) (x z)).
;;; We can also represent a graph similar to an
;;; adjacency matrix. We call this representation an
;;; x-graph (i.e. matrix-graph). In this case, a graph
;;; is a list of adjacencies where an adjacency is a
;;; list of length two such that the first element is a
;;; node (a symbol) and the second element is a list of
;;; the targets of that node. For example, the
;;; following is a graph: '((x (y z)) (y (z)) (z ())).
;;; Write function (el-graph->x-graph g), that accepts an el-graph g and returns an x-graph of g.
;;; Write function (x-graph->el-graph g), that accepts an x-graph g and returns an el-graph of g
;;;(define (el-graph->x-graph g))
;;;(define (x-graph->el-graph g))